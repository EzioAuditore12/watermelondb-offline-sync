import { Task } from "@/db/models/task.model";
import { mongooseTaskMapper } from "@/validators/mongoose-task-mapper";
import { PullChangesRequestParams } from "@/validators/pull-changes/request-body.schema";
import { PullChangesResponse } from "@/validators/pull-changes/response-body.schema";
import { PushChangesRequestBody } from "@/validators/push-changes/request-body.schema";
import { PushChangesResponseBody } from "@/validators/push-changes/response-body.schema";
import { TaskRequest } from "@/validators/task-response.schema";
import z from "zod";

export class TaskSevice {
  async pullChanges({
    lastSyncAt,
    tables,
  }: PullChangesRequestParams): Promise<PullChangesResponse> {
    const tasks = await Task.find({
      updated_at: { $gt: new Date(lastSyncAt) },
    }).lean();

    const mappedTasks = z.array(mongooseTaskMapper).parse(tasks);

    console.log(`Found ${tasks.length} tasks to sync.`);

    if (tasks.length > 0) {
      console.log("First task payload:", JSON.stringify(tasks[0], null, 2));
    }

    const created = mappedTasks.filter((t) => t.created_at > lastSyncAt);
    const updated = mappedTasks.filter((t) => t.created_at <= lastSyncAt);

    return {
      changes: {
        tasks: {
          created,
          updated,
          deleted: [],
        },
      },
      timestamp: Date.now(),
    };
  }

  async pushChanges({
    changes,
  }: PushChangesRequestBody): Promise<PushChangesResponseBody> {
    console.log("--- Push Request ---");
    console.log(`Received ${changes.length} changes to process.`);

    const created: TaskRequest[] = [];
    const updated: TaskRequest[] = [];
    const deleted: string[] = [];

    // Group the flat list of operations by type
    for (const change of changes) {
      if (change.tableName === "tasks") {
        const taskData = { ...change.data, id: change.recordId };

        switch (change.operation) {
          case "CREATE":
            created.push(taskData);
            break;
          case "UPDATE":
            updated.push(taskData);
            break;
          case "DELETE":
            deleted.push(change.recordId);
            break;
        }
      }
    }

    const results: PushChangesResponseBody["results"] = [];

    // Execute database operations
    // Note: We intentionally separate Create and Update logic now
    if (created.length > 0) {
      results.push(...(await this.createTasks(created)));
    }
    if (updated.length > 0) {
      results.push(...(await this.updateTasks(updated)));
    }
    if (deleted.length > 0) {
      results.push(...(await this.deleteTask(deleted)));
    }

    return {
      success: true,
      results,
    };
  }

  /**
   * Handles creation of NEW records.
   * Ignores the client's temporary ID for the database _id,
   * lets Mongoose generate a new unique _id, and returns the mapping.
   */
  private async createTasks(
    tasks: TaskRequest[]
  ): Promise<PushChangesResponseBody["results"]> {
    console.log(`Creating ${tasks.length} new tasks...`);
    const results: PushChangesResponseBody["results"] = [];

    for (const task of tasks) {
      console.log(`Creating task (Temp ID: ${task.id}) - ${task.name}`);
      try {
        // Create new document. Mongoose generates the _id automatically.
        const newDoc = await Task.create({
          name: task.name,
          is_completed: task.is_completed,
          created_at: new Date(task.created_at),
          updated_at: new Date(),
        });

        results.push({
          recordId: task.id, // The temporary ID sent by client
          serverId: newDoc._id.toString(), // The real ID generated by server
          serverUpdatedAt: Date.now(),
          error: undefined,
        });
      } catch (error: any) {
        console.error(`Error creating task ${task.id}:`, error);
        results.push({
          recordId: task.id,
          serverId: task.id, // Fallback (though sync might need retry)
          serverUpdatedAt: Date.now(),
          error: error.message || "Unknown error",
        });
      }
    }
    return results;
  }

  /**
   * Handles updates to EXISTING records.
   * Uses the ID sent by client (which should match server ID) to find and update.
   */
  private async updateTasks(
    tasks: TaskRequest[]
  ): Promise<PushChangesResponseBody["results"]> {
    console.log(`Updating ${tasks.length} existing tasks...`);
    const results: PushChangesResponseBody["results"] = [];

    for (const task of tasks) {
      console.log(`Updating task: ${task.id}`);
      try {
        await Task.updateOne(
          { _id: task.id },
          {
            $set: {
              name: task.name,
              is_completed: task.is_completed,
              // created_at usually shouldn't change on update, but ensuring consistency
              created_at: new Date(task.created_at),
              updated_at: new Date(),
            },
          }
        );

        results.push({
          recordId: task.id,
          serverId: task.id,
          serverUpdatedAt: Date.now(),
          error: undefined,
        });
      } catch (error: any) {
        console.error(`Error updating task ${task.id}:`, error);
        results.push({
          recordId: task.id,
          serverId: task.id,
          serverUpdatedAt: Date.now(),
          error: error.message || "Unknown error",
        });
      }
    }
    return results;
  }

  private async deleteTask(
    ids: string[]
  ): Promise<PushChangesResponseBody["results"]> {
    console.log(`Processing ${ids.length} deleted tasks...`);
    const results: PushChangesResponseBody["results"] = [];

    for (const id of ids) {
      console.log(`Deleting task: ${id}`);
      try {
        await Task.deleteOne({ _id: id });
        results.push({
          recordId: id,
          serverId: id,
          serverUpdatedAt: Date.now(),
          error: undefined,
        });
      } catch (error: any) {
        console.error(`Error deleting task ${id}:`, error);
        results.push({
          recordId: id,
          serverId: id,
          serverUpdatedAt: Date.now(),
          error: error.message || "Unknown error",
        });
      }
    }
    return results;
  }
}
